<!DOCTYPE html>
<html>
<head>
    <title>MIDI Ring demo</title>
    <style>
        * {
            box-sizing: border-box;
        }
        html,body {
            margin:0;
            padding:0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        button {
            cursor: pointer;
            border:0;
            background:#eee;
            padding:20px;
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: 30px;
        }
        article {
            max-width:1280px;
            margin: 50px auto;
            width:90%;
        }
        ul {
            list-style-type: none;
            margin:0;
            padding:0;
        }
        section.data_info,
        .positiondata {
            display:grid;
            grid-template-columns: 32% 32% 32%;
            gap:2%;
        }
        section.data_info>div,
        .positiondata li {
            padding:20px;
            background: #eee;
            font-size:0.75em;
            margin-bottom:30px;
        }
        .positiondata li {
            margin-bottom: 0;
        }
        section.data_info>div>p {
            margin:0;
            padding: 0;
        }
        section.data_info>div>h3 {
            margin-bottom: 0;
        }
        section.data_info>p {
            margin:3px 0 0 0;
            font-size:0.75em;
            font-weight: bold;
            text-transform: uppercase;
        }
        #midi_output_device,
        #midi_channel {
            height:120px;
            margin-bottom: 30px;
        }
        input[type=text],
        input[type=number] {
            width:100%;
            padding:5px;
            border:0;
            border-bottom:3px solid black;
            clear:both;
            margin-bottom: 3px;
        }
    </style>
</head>
<body>
    <article>
        <section class="data_info">
            <button id="connectButton">Connect</button>
            <button class="switch" data-v="A10404">RAW Data on</button>
            <button class="switch" data-v="A102">RAW Data off</button>

            <p>Capabilities</p>
            <p>Data received</p>
            <p>Status</p>

            <div id="capabilitiesDisplay"></div>
            <div id="dataDisplay"></div>
            <div id="statusDisplay"></div>

            <p>MIDI device</p>
            <p>MIDI channel</p>
            <p>&nbsp;</p>

            <select id="midi_output_device" size="6"><option>none</option></select>

            <select size="12" class="navi" id="midi_channel">
                <option value="0" selected>Channel 01</option>
                <option value="1">Channel 02</option>
                <option value="2">Channel 03</option>
                <option value="3">Channel 04</option>
                <option value="4">Channel 05</option>
                <option value="5">Channel 06</option>
                <option value="6">Channel 07</option>
                <option value="7">Channel 08</option>
                <option value="8">Channel 09</option>
                <option value="9">Channel 10</option>
                <option value="10">Channel 11</option>
                <option value="11">Channel 12</option>
                <option value="12">Channel 13</option>
                <option value="13">Channel 14</option>
                <option value="14">Channel 15</option>
                <option value="15">Channel 16</option>
            </select>
            <p>&nbsp;</p>

        </section>
        <h1>Rotational data</h1>
        <ul class="positiondata">
            <li id="data_x">X: 0</li>
            <li id="data_y">Y: 0</li>
            <li id="data_z">Z: 0</li>
            <li>
                <label for="assign_x">
                    <input id="assign_x" type="number" list="cc_list" name="assign_x" placeholder="assign CC number">
                    <datalist id="cc_list">
                        <option value="1">Modulation Wheel</option>
                        <option value="2">Breath Controller</option>
                        <option value="4">Foot Pedal</option>
                        <option value="7">Volume</option>
                        <option value="10">Pan</option>
                        <option value="11">Expression</option>
                        <option value="64">Sustain</option>
                        <option value="70">Variation</option>
                        <option value="71">Filter Resonance</option>
                        <option value="72">Release Time</option>
                        <option value="73">Attack Time</option>
                        <option value="74">Filter Cutoff Frequency</option>
                        <option value="91">Reverb depth</option>
                        <option value="92">Tremolo depth</option>
                        <option value="93">Chorus depth</option>
                        <option value="94">Detune</option>
                    </datalist>
                    X CC Number
                </label>
            </li>
            <li>
                <label for="assign_y">
                    <input id="assign_y" type="number" list="cc_list" name="assign_y" placeholder="assign CC number">
                    Y CC Number
                </label>
            </li>
            <li>
                <label for="assign_z">
                    <input id="assign_z" type="number" list="cc_list" name="assign_z" placeholder="assign CC number">
                    Z CC Number
                </label>
            </li>
        </ul>
    </article>

    <script>
        /**
         * get MIDI access
         */
        navigator.permissions.query({ name: "midi", sysex: true }).then((result) => {
            if (result.state === "granted") {
                // Access granted.
            } else if (result.state === "prompt") {
                // Using API will prompt for permission
            }
                // Permission was denied by user prompt or permission policy
        });

        /**
         * global variables
         */
        let midi = null;                            // global MIDIAccess object
        let midi_output=null;                       // output device
        var channel=0;                              // active channel
        var interpolation_current={x:0,y:0,z:0};    // current value we're sending on CC
        var interpolation_target={x:0,y:0,z:0};     // target value we're trying to reach
        var writeTarget=null;                       // we need to send some commands to the bluetooth ring, this var will hold the service id
        var interpolation_loop=null;                // a loop / interval which will interpolate midi values
        var ax,ay,az;

        /**
         * reads all the Uint8 numbers from the Data View we read from the Ring
         */
        function getAllUint8Values(dataView) {
            const values = [];
            for (let i = 0; i < dataView.byteLength; i++) {
                values.push(dataView.getUint8(i));
            }
            return values;
        }

        /**
         * convert hexadecimal number string to an array of bytes
         */
        function htb(h) {
            for (var bytes = [], c = 0; c < h.length; c += 2)
                bytes.push(parseInt(h.substr(c, 2), 16));
            return new Uint8Array(bytes);
        }

        /**
         * 12 bit long integer number representation
         */
        function int12(uint12) {
            return uint12 > 2047 ? uint12 - 4096 : uint12;
        }

        /**
         * Function to convert raw ADC value to G value for a ±4G accelerometer
         */
        function convertRawToG(rawValue) {
            const rangeG = 4; // ±4G
            return (rawValue / 2048) * rangeG;
        }

        /**
         * Scold the User when not giving MIDI access
         */
        function onMIDIFailure(msg) {
            alert("Y U do dis :-(");
            console.error(`Failed to get MIDI access - ${msg}`);
        }

        /**
         * Set up our MIDI connections
         */
        function onMIDISuccess(midiAccess) {
            midi = midiAccess; // store in the global (in real usage, would probably keep in an object instance)
            for (const entry of midiAccess.outputs) {
                midi_output = entry[1];
            }
            listOutputs(midiAccess);
            /** event handler for midi device selector */
            document.querySelectorAll("#midi_output_device").forEach(cb=>{
                cb.addEventListener("click",function(evt){
                    switch(this.id) {
                        case "midi_output_device":
                            midi_output = midiAccess.outputs.get(this.options[this.selectedIndex].value);
                            break;
                    }
                });
            });
            /** midi channel setup */
            document.getElementById("midi_channel").onclick=function(evt) {
                channel=this.value;
            }
        }

        /**
         * create a list of connected MIDI receivers
         */
        function listOutputs(midiAccess) {
            for (const entry of midiAccess.outputs) {
                const output = entry[1];
                /** create options */
                document.getElementById("midi_output_device").appendChild(new Option(output.name,output.id));
            }
        }

        /**
         * Send the CC command the user selected for X,Y,Z rotation values
         */
        function sendCC(cc, val) {
            /** the channel we send on is B0 + the channel selected by the user */
            var sendchannel=parseInt("B0",16);
            sendchannel="0x"+parseInt(parseInt(sendchannel)+parseInt(channel)).toString(16);
            const noteOnMessage = [sendchannel, cc, val]; 
            try {
                midi_output.send(noteOnMessage); // sends the message.
            }
            catch(error) {
                document.getElementById("midi_output_device").style.border="1px solid red";
            }
        }

        /**
         * User clicks "connect" Button and selects Ring, then ...
         */
        document.getElementById('connectButton').addEventListener('click', async () => {
            try {

                /**
                 * Don't waste too much time on the DOM stuff
                 */
                ax=document.getElementById("assign_x");
                ay=document.getElementById("assign_y");
                az=document.getElementById("assign_z");

                /**
                 * This will run 20 times a sec
                 */
                interpolation_loop=setInterval(function() {
                    /**
                     * I'm lazy
                     */
                    if(interpolation_current.x<interpolation_target.x) {
                        interpolation_current.x++;
                    }
                    if(interpolation_current.x>interpolation_target.x) {
                        interpolation_current.x--;
                    }
                    if(interpolation_current.y<interpolation_target.y) {
                        interpolation_current.y++;
                    }
                    if(interpolation_current.y>interpolation_target.y) {
                        interpolation_current.y--;
                    }
                    if(interpolation_current.z<interpolation_target.z) {
                        interpolation_current.z++;
                    }
                    if(interpolation_current.z>interpolation_target.z) {
                        interpolation_current.z--;
                    }
                    
                    // if user selected a target CC, send that MIDI value there
                    if(parseInt(ax.value)>0) {
                        sendCC(parseInt(ax.value),interpolation_current.x);
                    }
                    if(parseInt(ay.value)>0) {
                        sendCC(parseInt(ay.value),interpolation_current.y);
                    }
                    if(parseInt(az.value)>0) {
                        sendCC(parseInt(az.value),interpolation_current.z);
                    }
                },50);

                /**
                 * wait for the user to make a choice
                 */
                const device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: ['de5bf728-d711-4e47-af26-65e3012a5dc7', '6e40fff0-b5a3-f393-e0a9-e50e24dcca9e'] // Add the relevant service UUIDs here
                });

                /**
                 * Wait for Bluetooth connection to go online
                 */
                const server = await device.gatt.connect();
                const services = await server.getPrimaryServices();

                /**
                 * Display the services and characteristics of the selected BT device
                 */
                const capabilitiesDisplay = document.getElementById('capabilitiesDisplay');
                capabilitiesDisplay.innerHTML="";

                /**
                 * Go through all found services and attach an event listener to them (which will pick up the Data once it arrives)
                 */
                for (const service of services) {
                    capabilitiesDisplay.innerHTML += `<h3>Service: ${service.uuid}</h3>`;

                    const characteristics = await service.getCharacteristics();
                    for (const characteristic of characteristics) {
                        capabilitiesDisplay.innerHTML += "<p>Characteristic: "+characteristic.uuid+"</p>";

                        // Check if the characteristic supports notifications or indications
                        const properties = characteristic.properties;
                        if(properties.write&&writeTarget==null) {
                            // yes, it does. This is our writeTarget
                            writeTarget=characteristic;
                        }
                        if (properties.notify || properties.indicate) {
                            // Set up event listener for incoming data for each characteristic
                            characteristic.addEventListener('characteristicvaluechanged', (event) => {
                                // turn the raw data we picked up into a data view ...
                                const view=new DataView(event.target.value.buffer);
                                // ... and read all the Uint 8 values from that into an array ...
                                const value=(getAllUint8Values(view));
                                // we'll display a clock and the last set of data we picked up
                                const dataDisplay = document.getElementById('dataDisplay');
                                var now=new Date();
                                var milli = now.getMilliseconds(),
                                sec = now.getSeconds(),
                                min = now.getMinutes(),
                                hou = now.getHours();
                                dataDisplay.innerHTML = "<p><b>"+hou+":"+min+":"+sec+":"+milli+`</b> Received Data from ${characteristic.uuid}: `+value.join(",")+`</p>`;
                                /**
                                 * the second byte classifies the type of data we received. 
                                 * we're only interested in type 3 (position data). 
                                 * you might add clauses for heartbeat rate, blood pressure, temperature, o2 level and camera click if needed
                                 */
                                if(value[1]==3) {
                                    // the following byte shift code was stolen from Aaron Christophel's code (see https://www.youtube.com/@atc1441 )
                                    let rawY = int12((((value[2] << 4) | (value[3] & 0xf)) & 0xfff));
                                    let rawZ = int12((((value[4] << 4) | (value[5] & 0xf)) & 0xfff));
                                    let rawX = int12((((value[6] << 4) | (value[7] & 0xf)) & 0xfff));
                                    const Ax = convertRawToG(rawX);
                                    const Ay = convertRawToG(rawY);
                                    const Az = convertRawToG(rawZ);
                                    // most MIDI CC values are between 0 and 127, so we'll need to divide 127 by PI
                                    var ratio=127/Math.PI;
                                    // now multiply the rotation angle by that ratio to get a proper MIDI value
                                    rotateX = parseInt((Math.atan2(Ax, Math.sqrt(Ay * Ay + Az * Az))+Math.PI/2)*ratio);
                                    rotateY = parseInt((Math.atan2(Ay, Math.sqrt(Ax * Ax + Az * Az))+Math.PI/2)*ratio);
                                    rotateZ = parseInt((Math.atan2(Az, Math.sqrt(Ax * Ax + Ay * Ay))+Math.PI/2)*ratio);
                                    document.getElementById("data_x").innerHTML="X: "+rotateX;//value[2];
                                    document.getElementById("data_y").innerHTML="Y: "+rotateY;//value[3];
                                    document.getElementById("data_z").innerHTML="Z: "+rotateZ;//value[4];
                                    interpolation_target={x:rotateX,y:rotateY,z:rotateZ};
                                }
                            });

                            // Start notifications to receive incoming data
                            try {
                                await characteristic.startNotifications();  
                            } catch (error) {
                                console.warn(`Failed to start notifications for ${characteristic.uuid}: ${error.message}`);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error:', error);
            }
        });
    
        /**
         * User can click the "RAW DATA" button on or off; send the data assigned to them when that happens
         */
        document.querySelectorAll('button.switch').forEach((element) => {
            element.addEventListener('click', async () => {
                if (writeTarget) {
                    const data = htb(element.dataset.v);
                    var arrayOut = new Uint8Array(16);
                    for (let i = 0; i < data.length; i++) {
                        arrayOut[i] = data[i] & 0xff;
                        arrayOut[15] = (arrayOut[15] + arrayOut[i]) & 0xff;
                    }
                    try {
                        await writeTarget.writeValue(arrayOut);
                        document.getElementById('statusDisplay').innerText = 'Data sent successfully';
                    } catch (error) {
                        console.error('Error sending data:', error);
                        document.getElementById('statusDisplay').innerText = 'Error sending data';
                    }
                } else {
                    document.getElementById('statusDisplay').innerText = 'No writable characteristic found';
                }
            });
        });

        /**
         * Initialise MIDI once the page is loaded
         */
        navigator.requestMIDIAccess({sysex:true}).then(onMIDISuccess, onMIDIFailure);

    </script>
</body>
</html>
